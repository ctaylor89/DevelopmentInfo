C_Sharp
Docker_
Kuberneties_
Web_Site_Security
--------------------------------------------------------------------
C_Sharp

virtual: By default, methods are non-virtual. You cannot override a non-virtual method.
You cannot use the virtual modifier with the static, abstract, private, or override modifiers.

internal: The internal keyword is an access modifier for types and type members.

protected internal: Access is limited to types derived from the containing class(protected) or the current assembly(internal).
Note that: protected internal means "protected OR internal" (any class in the same assembly, or any derived class - even if it 
is in a different assembly).

private protected: Access is limited to the containing class or types derived from the containing class within the current assembly. 
Available since Csharp 7.2

The access level for class members and struct members, including nested classes and structs, is private by default.

Interfaces default to internal access.

Serialization is the process of converting an object into a stream of bytes to store the object or transmit it to memory, a database, or a file.

// Action objects return no values. The Action type is similar to a void method.
Action<int, int> example2 = (x, y) => Console.WriteLine("Write {0} and {1}", x, y);
// Call the anonymous methods with a number of arguments equal to the specific type of Action
   example2.Invoke(2, 3);

// The Func type provides a way to store anonymous methods in a generalized and simple way.
// Parameters bool and int, returns string.
Func<bool, int, string> func2 = (b, x) => string.Format("string = {0} and {1}", b, x);
Console.WriteLine(func2.Invoke(true, 10));

---
// Adding contstraints to a Generic class definition. The type must be of Employee or a sub class of Employee. This allows the class 
to access members of the Employee class.
public class GenericList<T> where T : Employee
{...}

// You can apply constraints to multiple parameters, and multiple constraints to a single parameter, as shown in the following example:
class Base { }
class Test<T, U>
    where U : struct 
    where T : Base, new() {...}     //Ex: Multiple constraints to a single parameter

Constraint			Description
where T: struct		Type argument must be a value type. Any value type except Nullable can be specified.
where T : class		Type argument must be a reference type; this applies also to any class, interface, delegate, or array type.
where T : new()		Type argument must have a public parameterless constructor. When used together with other constraints, the 
					new() constraint must be specified last.
where T : <base class name>
The type argument must be or derive from the specified base class.
where T : <interface name>
The type argument must be or implement the specified interface. Multiple interface constraints can be specified. The constraining 
interface can also be generic.
where T : U
The type argument supplied for T must be or derive from the argument supplied for U.
---
An abstract class is a special type of class that cannot be instantiated. An abstract class is designed to be inherited by subclasses 
that either implement or override its methods. You can have functionality in your abstract class. The methods in an abstract class can be both abstract and concrete. An abstract class can have constructors and this is one major difference between an abstract class and an interface. You can take advantage of abstract classes to design components and specify some level of common functionality that must be implemented by derived classes.
	public class MyMain : MyBase 
	{
		 MyMain(string myString) : base(myString){}
	}
---	
The main features of a C Sharp static class:
Static classes contain only static members, cannot be instantiated, is sealed, constructor only called once.

//C Sharp DataTypes
Value Types: integer, float, double, decimal, char, booleon, enum, struct, nullable
Reference Types: object, class, interface, array, delegate, uint, long, ulong, DateTime
---
A dependant class depends on its dependencies.
Two classes that uses each other are called "coupled". The coupling between classes can be loose or tight, or somewhere in between. 
The tightness of a coupling is not binary. It is not either "loose" or "tight". The degrees of tightness are continuous, not discrete. 
You can also characterize dependencies as "strong" or "weak". A tight coupling leads to strong dependencies, and a loose coupling leads 
to weak dependencies, or even no dependencies in some situations.

Dependencies, or couplings, are directional. That A depends on B doesn't mean that B also depends on A.
---
Managed objects are created, managed and under scope of CLR, pure .NET code is managed by the .Net runtime, Anything that lies 
within .NET scope and under .NET framework classes such as string, int, bool variables are referred to as managed code.

UnManaged objects are created outside the control of .NET libraries and are not managed by CLR, example of such unmanaged code is 
COM objects, file streams, connection objects, Interop objects. (Basically, third party libraries that are referred in .NET code.)
---
In a UI app such as Winforms or WPF, a "cross thread exception" occurs if you are accessing UI components from a background thread.
---
Thread represents an actual OS-level thread, with its own stack and kernel resources. Thread allows the highest degree of control; 
you can Abort() or Suspend() or Resume() a thread, you can observe its state, and you can set thread-level properties like the stack 
size, apartment state, or culture. ThreadPool is a wrapper around a pool of threads maintained by the CLR.

The Task class from the Task Parallel Library offers the best of both worlds. Like the ThreadPool, a task does not create its own OS 
thread. Instead, tasks are executed by a TaskScheduler; the default scheduler simply runs on the ThreadPool. Unlike the ThreadPool, 
Task also allows you to find out when it finishes, and (via the generic Task) to return a result.
---
Normalization is the process of organizing tables in a database to eliminate redundancy. This includes creating tables and establishing 
relationships between those tables according to rules designed both to protect the data and to make the database more flexible by 
eliminating redundancy and inconsistent dependency.

---------------------------------------------------------
Kuberneties_
- What is Helm: Helm is an open-source project that provides a better way to manage Kubernetes YAML files, using charts and templates.

- Why use Helm: Helm allows users to version, install, and update their Kubernetes applications with a single command, and to 
  customize their parameters with variables and functions.

- How to create a chart**: A chart is a bundle of one or more Kubernetes manifests that can be created with the helm create command and 
  follow a specific directory structure.

- How to publish a chart: A chart can be published on a public or private repository, which is basically an index.yaml file served from 
  a static web server. Users can tap these repositories to download and install charts.

Helm is widely known as "the package manager for Kubernetes". Although it presents itself like this, its scope goes way beyond that of a simple 
package manager.

Helm is an open-source project which was originally created by DeisLabs and donated to CNCF, which now maintains it. The original goal of Helm 
was to provide users with a better way to manage all the Kubernetes YAML files we create on Kubernetes projects. The path Helm took to solve 
this issue was to create Helm Charts. Each chart is a bundle with one or more Kubernetes manifests – a chart can have child charts and 
dependent charts as well.

This means that Helm installs the whole dependency tree of a project if you run the install command for the top-level chart. You just a single 
command to install your entire application, instead of listing the files to install via kubectl.

Charts allow you to version your manifest files too, just like we do with Node.js or any other package. This lets you install specific chart 
versions, which means keeping specific configurations for your infrastructure in the form of code.

Helm also keeps a release history of all deployed charts, so you can go back to a previous release if something went wrong.
---
In Kubernetes, a template file is a YAML or JSON file that describes a set of resources. These templates provide a way of managing and 
deploying applications in a repeatable and predictable manner.

Here are some key points about Kubernetes template files:

Templating YAML: Templating YAML in Kubernetes involves using tools such as yq and kustomize to template YAML resources. This allows 
you to create a placeholder in the YAML file and replace it with the real value before the YAML is submitted to the cluster.

Pod Template: A pod template is used for creating new pods, including container specifications, image names, and container ports.

Configuration Template Pattern: The main configuration file is a skeleton (template) that gets changed at start up according to the 
intended scenario.

These templates help in managing multiple Kubernetes clusters, as it’s common to have resources that can be applied to all environments 
but with small modifications. For example, when an app runs in the staging environment, it should connect to the staging database. 
However, in production, it should connect to the production database. In such cases, Kubernetes templates are very useful. They allow for 
the creation of reusable and composable components that can be used in different applications.

Example:
Suppose you have a microservice that requires different database connection settings (such as host, port, and credentials) depending 
on the environment. Instead of hardcoding these values in your Kubernetes YAML files, you create a configuration template with 
placeholders (e.g., {{DB_HOST}}, {{DB_PORT}}, {{DB_USER}}, {{DB_PASSWORD}}).
During deployment, you provide environment-specific values for these placeholders (e.g., via environment variables or ConfigMaps).
Kubernetes processes the template, substitutes the placeholders with actual values, and applies the resulting configuration to the 
running pod.
---
Composability is a system design principle that deals with the inter-relationships of components. A highly composable system provides 
components that can be selected and assembled in various combinations to satisfy specific user requirements. In information systems, 
the essential features that make a component composable are that it be:

self-contained (modular): it can be deployed independently – note that it may cooperate with other components, but dependent components are replaceable
stateless:[citation needed] it treats each request as an independent transaction, unrelated to any previous request. Stateless is just one technique; managed state and transactional systems can also be composable, but with greater difficulty.
It is widely believed that composable systems are more trustworthy than non-composable systems because it is easier to evaluate their individual parts.
---
`yq` is a command-line tool designed to transform YAML¹². It is similar to `jq`, which focuses on transforming JSON instead of YAML. 
Here are some of the things `yq` can do:
1. Read values from a YAML file.
2. Add new values to a YAML file.
3. Update existing values in a YAML file.
4. Generate new YAML files.
5. Convert YAML into JSON.
6. Merge two or more YAML files.

`yq` is particularly useful in Kubernetes, where YAML files are commonly used for configuration¹. It provides a lightweight option for templating YAML files, which can be helpful when you want to update the fields in your YAML files¹. This makes `yq` a great tool for handling Kubernetes resource fields without leaving the command-line?.

*************************************************
Skip Recording this
Source: Conversation with Bing, 1/26/2024
(1) yq : Is a command line tool that will help you handle your YAML resources .... https://dev.to/vikcodes/yq-a-command-line-tool-that-will-help-you-handle-your-yaml-resources-better-8j9.
(2) GitHub - mikefarah/yq: yq is a portable command-line YAML, JSON, XML .... https://github.com/mikefarah/yq.
(3) Processing kubectl YAML Output with yq - Medium. https://mannymon.medium.com/processing-kubectl-yaml-output-with-yq-bf0dc98ddeab.
(4) Templating YAML in Kubernetes with real code - Learnk8s. https://learnk8s.io/templating-yaml-with-code.
(5) undefined. https://github.com/mikefarah/yq/releases/download/.
(6) undefined. https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64.
*************************************************
-----------------------------------------------------------------
Docker_
A Docker container image is a lightweight, standalone, executable package of software that includes everything needed to run an 
application. This includes the code, runtime, system tools, system libraries, and settings.

Here are some key points about Docker container images:

Standardization: Docker container images provide a standardized unit of software that packages up code and all its dependencies. 
This ensures the application runs quickly and reliably from one computing environment to another.

Portability: Docker container images are platform-independent. They can run on any infrastructure that supports Docker, including both 
Linux and Windows-based systems.

Efficiency: Docker container images are lightweight and take up less space than virtual machines. They share the machine’s OS system 
kernel and do not require an OS per application, driving higher server efficiencies.

Runtime: Container images become containers at runtime. In the case of Docker containers, images become containers when they run on 
Docker Engine.

Isolation: Docker provides strong isolation capabilities, ensuring applications are safer in containers.
Docker container images are just the blueprint for a container. When you run a Docker container image, it becomes a Docker container.

--------------------------------------------------------
APPLICATION VIRTUALIZATION AND CONTAINER VIRTUALIZATION

Application virtualization is a more limited type of virtual desktop infrastructure (VDI). Rather than run the whole client desktop 
as a virtual platform, the client either accesses an application hosted on a server or streams the application from the server to 
the client for local processing. Most application virtualization solutions are based on Citrix XenApp , though Microsoft has developed 
an App-V product with its Windows Server range and VMware has the ThinApp product. These solution types are often used with HTML5 remote 
desktop apps, referred to as "clientless" because users can access them through ordinary web browser software.

Containerization dispenses with the idea of a hypervisor and instead enforces resource separation at the operating system level. 
The OS defines isolated "cells" for each user instance to run in. Each cell or container is allocated CPU and memory resources, but the 
processes all run through the host OS kernel. These containers may run slightly different OS distributions but cannot run different 
types of guest OSes (e.g. you could not run Windows in a Red Hat Linux container, for instance). Alternatively, the containers might 
run separate application processes, in which case the variables and libraries required by the application process are added to the 
container.

One of the best-known container virtualization products is Docker (docker.com). Containerization underpins many cloud services. 
In particular, it supports microservices and serverless architecture. Containerization is also being widely used to implement corporate 
workspaces on mobile devices.
--------------------------------------------------------
Architecture Considerations

Compute Resources are Processing, memory, storage, and networking resources that allow a host or network appliance to handle a given workload.
A scalable system is one that can quickly or automatically add or remove compute resources without incurring excessive costs.

Resilience is the ability of a system or network to recover quickly from failure events with no or minimal manual intervention.
Patch availability ensures that firmware and software code is protected against exploits for known vulnerabilities.

A serverless architecture is where the cloud provider manages the infrastructure and automatically scales resources up or down based 
on demand. This model can be more secure than traditional architectures because the cloud provider manages and secures the infrastructure. 
However, customers must still take steps to secure access to their applications and data.
--------------------------------------------------------
A hybrid cloud most commonly describes a computing environment combining public and private cloud infrastructures, although any 
combination of cloud infrastructures constitutes a hybrid cloud. In a hybrid cloud, companies can store data in a private cloud but 
also leverage the resources of a public cloud when needed. 

Service-level agreements, (SLAs), formally outline all performance, availability, and support expectations between the cloud service 
provider and the organization. Guaranteeing expected levels of service can be challenging when dealing with the integration of different 
cloud and on-premises systems.
*************************************************
*************************************************
*************************************************
	1) Already recorded up to this point
*************************************************
*************************************************
*************************************************
Entity Framework Core is an object-relational mapper (ORM). An ORM provides a layer between the domain model that you implement 
in code and a database. EF Core is a data access API that allows you to interact with the database by using .NET plain old Common 
objects (POCOs) and strongly typed Language Integrated Query (LINQ) syntax.

With EF Core, you can:
Load data as C# objects (entities), Add, modify, and delete data by calling methods on the entities. You can Handle concurrency 
issues that arise when multiple users simultaneously attempt to update the same record.

You can use strongly typed LINQ syntax to query the database and build your domain model from an existing database.
Commit changes to complex, deep, or wide object graphs of related entities by using a single method call.

DbContext provides methods that you can use to configure options, connection strings, logging, and the model that's used to map 
your domain to the database.

Classes that derive from DbContext:
Represent an active session with the database.
Save and query instances of entities.
Include properties of type DbSet<T> that represent tables in the database.
The EF Core Provider translates object graph changes to SQL.

The database provider is a plug-in library that's designed for a specific database engine, such as SQL Server or Azure Cosmos DB.
The database provider translates method calls and LINQ queries to the database's native SQL dialect.
Extends EF Core to enable functionality that's unique to the database engine.

The EF Core migrations feature provides a way to incrementally update the database schema to keep it in sync with changes to 
the application's data model while preserving existing data in the database.

Reverse engineering in the context of Entity Framework is the process of scaffolding entity model classes and a DbContext class 
based on a database schema.
--------------------------------------------------------
About DTOs:
Sometimes you want to change the shape of the data that you send to client. For example, you might want to:

Remove circular references (see previous section).
Hide particular properties that clients are not supposed to view.
Omit some properties in order to reduce payload size.
Flatten object graphs that contain nested objects, to make them more convenient for clients.
Avoid "over-posting" vulnerabilities. (See Model Validation for a discussion of over-posting.)
Decouple your service layer from your database layer.
To accomplish this, you can define a data transfer object (DTO). A DTO is an object that defines how the data will be sent over 
the network.
--------------------------------------------------------
IQueryable serves a specific purpose when dealing with data manipulation and querying. Let’s explore its significance:

Deferred Execution and Query Expressions:
IQueryable<T> is an abstraction that encapsulates LINQ expressions. These expressions describe how to obtain a collection of 
data, but the actual data retrieval doesn’t occur until you evaluate it (for example, by turning it into an IEnumerable or 
similar).  Unlike IEnumerable<T>, which immediately retrieves data from the source (such as a database), IQueryable<T> builds a 
query expression that remains unevaluated until explicitly invoked. This deferred execution allows you to compose queries and 
apply additional filtering before the query is sent to the database.

LINQ Providers and Translation to SQL:
IQueryable<T> is used by LINQ providers (such as Entity Framework) to translate LINQ expressions into SQL queries.
When you work with an IQueryable<T>, the LINQ provider interprets the expression tree and generates SQL statements that are sent 
to the database. Different LINQ providers for databases like SQL Server, interpret LINQ expressions differently, adapting them 
to their specific query language.

Efficient Querying for Remote Data Sources:
IQueryable<T> is particularly useful for querying remote data sources (e.g., databases), efficiently.
By allowing the query to execute on the server side, it minimizes unnecessary data retrieval and filtering in memory.
You can apply additional .Where clauses or other query operators before the actual execution, optimizing the database query.

Terminal Methods and Evaluation:
IQueryable<T> is evaluated only when a “terminal” method is called upon it. Examples of terminal methods include ToList(), 
ToArray(), Single(), Count(), Any(), etc.  At this point, the LINQ provider translates the expression into the appropriate 
query language (e.g., SQL) and fetches the results.
--------------------------------------------------------
Use the LINQ Select statement to convert from Book entities into DTOs.
    // GET api/Books
    public IQueryable<BookDto> GetBooks()
    {
        var books = from b in db.Books
                    select new BookDto()            // Other properties of the book class are omitted when creating this new object
                    {
                        Id = b.Id,
                        Title = b.Title,
                        AuthorName = b.Author.Name
                    };

        return books;
    }

    // GET api/Books/5
    [ResponseType(typeof(BookDetailDto))]
    public async Task<IHttpActionResult> GetBook(int id)
    {
        var book = await db.Books.Include(b => b.Author).Select(b =>
            new BookDetailDto()
            {
                Id = b.Id,
                Title = b.Title,
                Year = b.Year,
                Price = b.Price,
                AuthorName = b.Author.Name,
                Genre = b.Genre
            }).SingleOrDefaultAsync(b => b.Id == id);
        if (book == null)
        {
            return NotFound();
        }

        return Ok(book);
    }
--------------------------------------------------------
The ResponseType annotation in a .NET MVC Web API controller action is used to specify the type of the response that an action method 
returns. It provides important metadata that can be used by help pages and clients to understand the data being returned by the API. 

Here are some key points about the ResponseType annotation:
Descriptive Metadata: It helps to produce more descriptive response details for API help pages generated by tools like Swagger.
Client Expectations: It informs clients about what type of object they should expect in the response, which can aid in deserialization.
Documentation Clarity: It improves the clarity of the API documentation, making it easier for developers to understand the API’s behavior.
In summary, the ResponseType annotation enhances the developer experience by providing clear expectations about the API’s response types.
--------------------------------------------------------
To Setup a new database and connect to it from Entity Framework:

Add connection string to the appsettings.json file in .Net Core application
add-migration MyNewMigrationName
update-database                  // Push the migration up to the database
--------------------------------------------------------
In ASP.NET Core, the ValidateAntiForgeryToken attribute plays a crucial role in preventing Cross-Site Request Forgery (CSRF) 
attacks. Let’s dive into how it works:

What is CSRF?
CSRF is an attack where a malicious website tricks a user’s browser into performing actions on another website where the user is 
authenticated. The attacker exploits the user’s existing session to perform unauthorized actions without their knowledge.

Example of a CSRF Attack:
Imagine a user is authenticated on a banking website (www.good-banking-site.example.com).
The attacker creates a malicious site (www.bad-crook-site.example.com) containing a hidden form that posts to the banking site.
When the user visits the malicious site, the form automatically submits to the banking site, using the user’s authentication context.
The banking site processes the request, assuming it’s legitimate, because it trusts any request with a valid authentication cookie.

How ValidateAntiForgeryToken Works
The ValidateAntiForgeryToken attribute ensures that only authenticated users can submit forms or perform actions on the server.
It requires a token for requests to the action methods it marks, including HTTP GET requests.
The token is generated and embedded in the form during rendering.
When the form is submitted, the server validates the token to ensure it matches the expected value.
If the token is missing or invalid, the server rejects the request.

Apply the ValidateAntiForgeryToken attribute to your controller actions that handle form submissions (usually HTTP POST actions).

Additional Notes:
The ValidateAntiForgeryToken attribute can be applied globally across the app’s controllers but can be overridden using the 
IgnoreAntiforgeryToken attribute. Using HTTPS doesn’t prevent CSRF attacks; the malicious site can send requests over HTTPS as 
easily as over HTTP. Remember, ValidateAntiForgeryToken is a powerful defense mechanism against Cross-Site Request Forgery (CSRF) 
attacks in ASP.NET Core. Always use ValidateAntiForgeryToken for form submissions to enhance your application’s security!
--------------------------------------------------------
The value attribute of an HTML input element is used to specify the initial value or default value for the input field. When a 
user interacts with the input (such as typing in a text field or selecting an option in a dropdown), the value can change dynamically.

Here are some common use cases for the value attribute:
Text Input Fields:
For text input fields (e.g., <input type="text">), the value attribute sets the initial text displayed in the input box.
Example:
    <input type="text" value="Default Text">

Radio Buttons and Checkboxes:
For radio buttons and checkboxes, the value attribute specifies the value associated with that option when it is selected.
Example:
    <input type="radio" name="gender" value="male"> Male
    <input type="radio" name="gender" value="female"> Female

Dropdowns (Select Elements):
For <select> elements (dropdowns), each <option> can have a value attribute that represents the value associated with the 
selected option.
Example:
    <select>
        <option value="apple">Apple</option>
        <option value="banana">Banana</option>
        <option value="orange">Orange</option>
    </select>

Hidden Fields:
For hidden input fields (e.g., <input type="hidden">) use the value attribute to store data that is not visible to the user but 
can be submitted with a form.
Example:
    <input type="hidden" name="user_id" value="123">

Remember that the value attribute is static and does not change automatically based on user input. If you want to capture user 
input dynamically, you’ll need to use JavaScript or other event handlers to change the value assigned to the value attribute.
--------------------------------------------------------
EditorFor: This control renders HTML markup based on the datatype of the property. E.g. suppose there is a boolean property in the 
model. To render this property in the view as a checkbox we can use CheckBoxFor or EditorFor. Both will be generate the same markup.
If the property in the model is text, then the property will be rendered in the view as TextBoxFor would render it
--------------------------------------------------------
Tag Helpers
ASP.NET Core Tag Helpers allow server-side code to participate in creating and rendering HTML elements within Razor files.
Tag Helpers enable you to define custom HTML elements in your Razor views using C# code.
They provide an alternative approach to creating and manipulating HTML compared to traditional HTML Helpers.

There are many Tag Helpers available in public GitHub repositories and as NuGet packages.
Remember that Tag Helpers don’t replace HTML Helpers entirely; they provide an alternative approach and coexist with HTML 
Helpers and there's not a Tag Helper for each HTML Helper.

Tag Helpers reduce the explicit transitions between HTML and C# in Razor views. The Microsoft.AspNetCore.Mvc.TagHelpers 
assembly contains the built-in Tag Helpers.
---
Tag Helper Examples:
    The following Razor markup:
        <label asp-for="Movie.Title"></label>
    Generates the following HTML:
        <label for="Movie_Title">Title</label>
---
The @addTagHelper directive makes Tag Helpers available to the views. In this case, the view file is Pages/_ViewImports.cshtml, 
which by default is inherited by all files in the Pages folder and subfolders; making Tag Helpers available. The code above uses 
the wildcard syntax ("*") to specify that all Tag Helpers in the specified assembly (Microsoft.AspNetCore.Mvc.TagHelpers) will be 
available to every view file in the Views directory or subdirectory.

@addTagHelper *, Microsoft.AspNetCore.Mvc.TagHelpers
Using "*" for all Tag Helpers. "Microsoft.AspNetCore.Mvc.TagHelpers" specifies the assembly containing the Tag Helpers.
Using @removeTagHelper in a Views/Folder/_ViewImports.cshtml file removes the specified Tag Helper from all of the views in Folder.

You can disable a Tag Helper at the element level with the Tag Helper opt-out character ("!"). For example, Email validation is 
disabled in the <span> with the Tag Helper opt-out character:
    <!span asp-validation-for="Email" class="text-danger"></!span>
---
Setting a tag helper prefix: @tagHelperPrefix th:
In the code image below, since the Tag Helper prefix is set to th:, only those elements using the prefix th: will support Tag Helpers 
(Tag Helper-enabled elements have a distinctive font). The <label> and <input> elements have the Tag Helper prefix and are Tag 
Helper-enabled, while the <span> element doesn't.

Razor markup with Tag Helper prefix set to "th:" for a label and an input element name

The same hierarchy rules that apply to @addTagHelper also apply to @tagHelperPrefix.
---
Many Tag Helpers can't be used as self-closing tags. Some Tag Helpers are designed to be self-closing tags. Using a Tag Helper that 
was not designed to be self-closing suppresses the rendered output.

Reference:https://learn.microsoft.com/en-us/aspnet/core/mvc/views/tag-helpers/intro?view=aspnetcore-8.0
--------------------------------------------------------
Route Templates in .Net core:
  Route templates define how URL paths are matched to actions. Route templates can be defined either at startup in Program.cs 
  (conventional Routing) or using attributes on the controller action methods(Attribute Routing). Each controller action 
  method can be decorated with route attributes defining the templates. These templates specify the URL patterns that the 
  action will handle. Commonly used attributes include [Route], [HttpGet], [HttpPost], [HttpPut], and [HttpDelete].
  Templates can include various segments and parameters (like IDs) that pass data to the controller methods. Conventional 
  routing is typically used with controllers and views. Attribute routing is commonly used for REST APIs.
--------------------------------------------------------
POCO stands for Plain Old CLR Object. It’s a term commonly used in the context of object-oriented programming and data persistence. 

Definition:
A POCO is a .NET data structure that contains only public properties or fields.
It doesn’t derive from any special base class, nor does it return any special types for its properties.
Essentially, a POCO is just a plain old class without any bells and whistles.
Characteristics of a POCO:
Pure Class: It’s a pure C# or VB.NET class.
No Framework Dependencies: It doesn’t depend on any framework-specific base class.
Persistence-Ignorant: It doesn’t contain any code or attributes specific to an ORM (Object-Relational Mapping) framework.
    public class Customer
    {
        public int Id { get; set; }
        public string Name { get; set; }
    }

*************************************************
*************************************************
*************************************************
*************************************************
*************************************************
*************************************************
	2) Already recorded up to this point  05/02/2024
*************************************************
*************************************************
*************************************************
*************************************************
*************************************************

--------------------------------------------------------
Difference between Html.Partial() and Html.RenderPartial() in ASP.NET MVC
---
AI

The Html.Partial() and Html.RenderPartial() methods in ASP.NET MVC serve similar purposes, but there are important differences between them:

Html.Partial():
Returns: An MvcHtmlString (a string that can be assigned to a variable).
Usage: You can store the output in a variable or return it from a method.
Behavior: The result is constructed inline with the parent view and accesses the parent’s model.
Use Case: When you need to manipulate the output or assign it to a variable.

Html.RenderPartial():
Returns: void (does not return anything).
Usage: It writes directly to the output stream during execution/evaluation.
Behavior: The result is written to the response stream immediately.
Use Case: When you want to render the partial view directly without storing the output.

In summary:
Use Html.Partial() when you need to manipulate the output or store it in a variable.
Use Html.RenderPartial() when you want to render the partial view directly without returning any value

Html.Partial injects the html string of the partial view into the main view.
Html.RenderPartial writes html to the HTTP response stream means it used the same Text Writer object as used in the current 
webpage/template. The Html.RenderPartial method returns void. Simple to use and no need to create any action. RenderPartial method 
is useful when the displaying data in the partial view is already in the corresponding view model. For example : In a blog to show 
comments of an article, we would like to use Render Partial method since an article information with comments are already populated in the view model. @{Html.RenderPartial("_Comments");} 5.This method is faster than Partial method since its result is directly written to the response stream which makes it fast.Html.Partial1. Renders the partial view as an HTML-encoded string. 2. This method result can be stored in a variable, since it returns string type value. 3. Simple to use and no need to create any action. 4. Like Render Partial method, Partial method is also useful when the displaying data in the partial view is already in the corresponding view model. . @Html.Partial("_Comments")For Performance : @Html.RenderPartial("_OrderPage") is better than @Html.Partial("_OrderPage")
---
Html.Partial returns a String. Html.RenderPartial calls Write internally and returns void.

The basic usage is:

// Razor syntax
@Html.Partial("ViewName")
@{ Html.RenderPartial("ViewName");  }
Html.Partial() need not to be inside the braces.	Html.RenderPartial must be inside braces @{ }

// WebView syntax
<%: Html.Partial("ViewName") %>
<% Html.RenderPartial("ViewName"); %>
In the snippet above, both calls will yield the same result.

While one can store the output of Html.Partial in a variable or return it from a method, one cannot do this with Html.RenderPartial.

The result will be written to the Response stream during execution/evaluation.

This also applies to Html.Action and Html.RenderAction.
---
Think of @Html.Partial as HTML code copied into the parent page. Think of @Html.RenderPartial as an .ascx user control incorporated 
into the parent page. An .ascx user control has far more overhead.

'@Html.Partial' returns a html encoded string that gets constructed inline with the parent. It accesses the parent's model.

'@Html.RenderPartial' returns the equivalent of a .ascx user control. It gets its own copy of the page's ViewDataDictionary and 
changes made to the RenderPartial's ViewData do not effect the parent's ViewData.
--------------------------------------------------------
In an HTML document, the <section> tag defines a standalone section of functionality. It’s typically used for grouping related 
content together, often with a heading. Here are some key points about the <section> tag:

Semantic Purpose:
Unlike generic containers like <div>, the <section> tag has semantic meaning. It helps search engines understand the structure of 
your content. Use it for thematically grouped content within your document.
--------------------------------------------------------
In HTML5, the <dialog> tag serves as a versatile element for creating modal or non-modal dialog boxes and other interactive components. Here are the key points about the <dialog> tag:

Modal and Non-Modal Dialogs:
The <dialog> element can be used to create both modal and non-modal dialog boxes.
Modal dialogs interrupt interaction with the rest of the page, rendering the rest of the page inert.
Non-modal dialogs allow interaction with the rest of the page while the dialog is open.

Activation and Display:
JavaScript should be used to display the <dialog> element.
To show a modal dialog, use the .showModal() method.
To display a non-modal dialog, use the .show() method.

Closing Dialogs:
You can close a dialog using the .close() method.
When submitting a <form> nested within a <dialog>, the dialog can also be closed.
Modal dialogs can be closed by pressing the Esc key.
Attributes:
The <dialog> element includes global attributes.
Avoid using the tabindex attribute on <dialog>.
Instead, use HTML <form> elements with method="dialog" or buttons with formmethod="dialog" to close the dialog.
Styling and Interaction:
Use the ::backdrop pseudo-element to style the backdrop behind a modal dialog.
Add the autofocus attribute to the element that should receive immediate interaction upon opening a modal dialog.

Example:
Here’s an HTML-only example of creating a non-modal dialog:
HTML

<dialog open>
    <h2>Important Message</h2>
    <p>This is an important notice.</p>
    <button onclick="this.closest('dialog').close()">Close</button>
</dialog>
--------------------------------------------------------
Webpack is a powerful module bundler for web development. Its primary purpose is to bundle JavaScript files, styles, images, 
and other resources into a single file for efficient deployment. Here are the key points about Webpack:

Webpack’s main focus is on bundling JavaScript modules.
It takes your code, along with its dependencies, and creates a single output file (usually named bundle.js).

While JavaScript is its primary use case, Webpack is also capable of handling other assets like stylesheets, images, fonts, 
and more. It can transform, bundle, or package any resource or asset needed for your web application.

You can use Webpack without any configuration, and it will bundle your assets based on sensible defaults.
However, you can also provide a custom webpack.config.js file to tailor the behavior according to your project’s needs.
--------------------------------------------------------
Flexbox, also known as the Flexible Box Layout, is a powerful CSS method for arranging items within a container. Here are the 
key points about flexbox:

One-Dimensional Layout:
Flexbox operates in one dimension at a time, either as a row or a column.
Unlike the two-dimensional model of CSS Grid Layout, which controls both columns and rows together, flexbox focuses on a single 
axis at a time.
--------------------------------------------------------
Unsubscribing from Events in C Sharp:
When an object subscribes to an event, it holds a reference to the event handler. If not properly unsubscribed, this can lead to 
memory leaks. To prevent resource leaks, you should unsubscribe from events before disposing of an object.
--------------------------------------------------------
System.IO.FileStream is a .net class, but the actual filestream itself isn't, it is something supplied by the operating system as 
an abstracted way of interacting with the hardware of the hard drive.  Likewise the actual connection to your database is being 
provided by non .net database drivers and libraries, and ultimately comes down to a TCP socket, named pipe or some other operating 
system provided cross-process communication channel.  As none of these low level things are under the control of .net, they live 
outside of the .net framework so need to be disposed of using their own individual native methods.
--------------------------------------------------------
The order of precedence for CSS rules determines which styles take precedence when multiple rules apply to an element. Here are
the key factors in determining precedence:

Inline CSS: Styles defined directly in the HTML using the style attribute override other CSS rules. Inline styles have the highest 
specificity and take precedence over other selectors.

Specificity: More specific selectors take precedence over less specific ones. The specificity hierarchy is as follows 
(from highest to lowest):
    IDs (e.g., #main)                               // Elements referenced by IDs
    Classes (e.g., .myclass)                        // Elements referenced by class
    Attribute selectors (e.g., [href^="https://"])  // Elements referenced by attribute
    Pseudo-classes (e.g., :hover)
    Elements (e.g., div)
    Pseudo-elements (e.g., ::before)
    Order of Appearance: If two rules have the same specificity, the one declared later in the code overrides the earlier one. So, 
    the order of appearance matters. If both rules have the same specificity and appear in the same location, the last one takes 
    precedence. !important: A CSS rule marked with !important always takes precedence over other rules, regardless of specificity or order1.
--------------------------------------------------------
CSS Pseudo Classes
Pseudo-classes in CSS are keywords that modify selectors to target and style elements based on their state or context. 
They allow you to apply styles to elements beyond what standard selectors can achieve.

Syntax:
 Pseudo-classes start with a colon (:) followed by the pseudo-class name.
 Pseudo-classes are added to selectors to define special states of elements.
    selector:pseudo-class {
        property: value;
    }

    /* Match the first <p> element */
    p:first-child { color: blue; }

Common Use Cases are:
 :hover: Styles an element when the user hovers over it (e.g., changing link colors on hover).
 :visited: Styles visited links differently from unvisited links.
 :focus: Styles an element when it receives focus (e.g., input fields).
 :first-child: Selects the first child of a parent element.
 :lang: Allows you to define rules for different languages (e.g., styling quotes based on language).

Other Use Cases are:
    a:link      link in normal state
    a:active    link in clicked state
    a:hover     link with mouse over it
    a:visited   visited link
    p::after{content:"yo";}     add content after p
    p::before                   add content before p
    input:checked               All checked inputs
    input:disabled              All disabled inputs
    input:enabled               All enabled inputs
    input:focus                 input has focus
    input:in-range              value in range
    input:out-of-range          input value out of range
    input:valid                 input with valid value
    input:invalid               input with invalid value
    input:optional              no required attribute
    input:required              input with requred attribute
    input:read-only             input with readonly attribute
    input:read-write            no readonly attrib.
    div:empty                   element with no children
    p:first-letter             first letter in p
    p:first-line               first line in p
    p:first-of-typefirst of some type
    p:last-of-typelast of some type
    p:lang(en)p with en language attribute
    :not(span)element that's not a span
    p:first-childfirst child of its parent
    p:last-childlast child of its parent
    p:nth-child(2)second child of its parent
    p:nth-child(3n+1)nth-child (an + b) formula
    p:nth-last-child(2)second child from behind
    p:nth-of-type(2)second p of its parent
    p:nth-last-of-type(2)...from behind
    p:only-of-typeunique of its parent
    p:only-childonly child of its parent
    :rootdocuments root element
    ::selectionportion selected by user
    :targethighlight active anchor
--------------------------------------------------------
Common HTTP Status Codes
-------------------------
200 OK: General success response for various types of requests.
201 Created: Indicates successful creation of a new resource.
-------------------------
Status Code 200 – This is the standard “OK” status code for a successful HTTP request. The response that is returned is dependent 
on the request. For example, for a GET request, the response will be included in the message body. For a PUT/POST request, the 
response will include the resource that contains the result of the action.

Status Code 201 – This is the status code that confirms that the request was successful and, as a result, a new resource was created. 
Typically, this is the status code that is sent after a POST/PUT request.

Status Code 204 – This status code confirms that the server has fulfilled the request but does not need to return information. 
Examples of this status code include delete requests or if a request was sent via a form and the response should not cause the form to be 
refreshed or for a new page to load.

Status Code 304 – The is status code used for browser caching. If the response has not been modified, the client/user can continue to use 
the same response/cached version. For example, a browser can request if a resource has been modified since a specific time. If it hasn’t, 
the status code 304 is sent. If it has been modified, a status code 200 is sent, along with the resource.

Status Code 400 – The server cannot understand and process a request due to a client error. Missing data, domain validation, and invalid 
formatting are some examples that cause the status code 400 to be sent.

Status Code 401 – This status code request occurs when authentication is required but has failed or not been provided.

Status Code 403 – Very similar to status code 401, a status code 403 happens when a valid request was sent, but the server refuses to 
accept it. This happens if a client/user requires the necessary permission or they may need an account to access the resource. Unlike 
a status code 401, authentication will not apply here.

Status Code 404 – A status code 404 occurs when the request is valid, but the resource cannot be found on the server. Even though 
these are grouped in the Client Errors “bucket,” they are often due to improper URL redirection.

Status Code 409 – A status code 409 is sent when a request conflicts with the current state of the resource. This is usually an 
issue with simultaneous updates, or versions, that conflict with one another.

Status Code 410 – Resource requested is no longer available and will not be available again.

Status Code 500 – The 500 series codes are similar to the 400 series codes in that they are true error codes. The status code 500 
happens when the server cannot fulfill a request due to an unexpected issue. Web developers typically have to comb through the 
server logs to determine where the exact issue is coming from.
--------------------------------------------------------
SQL injection attacks, which inject malicious SQL commands into a website's database and compromise its data or functionality.
Cross-site scripting (XSS) attacks, which inject malicious scripts into a website and execute them on a user's browser, affecting 
their session or stealing their data.
--------------------------------------------------------
The stopPropagation() and stopImmediatePropagation() methods in jQuery are called on the event object that is passed to the event 
handler function and are used to control the propagation of events in the DOM. 

The stopPropagation() method prevents the event from bubbling up to parent dom elements.
When called within an event handler, the stopPropagation() method stops the event from reaching any parent elements by preventing 
the event from propagating further up the DOM tree. The stopPropagation() method does not prevent other event handlers on the same 
element from executing.

The stopImmediatePropagation() method goes a step further than stopPropagation().
The stopImmediatePropagation() method not only prevents the event from bubbling up to parent elements but also prevents any other 
event handlers on the same element from executing. If you call stopImmediatePropagation() within an event handler, no other handlers 
(including those on the same element) will be executed for that event.
---
To check the event propogation status, you can use event.isPropogationStopped(), event.isImmediatePropagationStopped() and 
event.isDefaultPrevented.
--------------------------------------------------------
The ?? operator in C# is called the null-coalescing operator. It allows you to define a default value for a nullable value type or a 
reference type. Here’s how it works:
    If the left-hand operand is not null, the operator returns the value of the left-hand operand.
    If the left-hand operand is null, the operator returns the value of the right operand.

    string? userInput = null; // Simulating a null value
    string result = userInput ?? "Default Value";

Note that in JavaScript the null-coalescing operator uses double pipes(||) instead of double question marks (??).
--------------------------------------------------------
To enhance the performance of your C# backend code, consider implementing the following optimizations:

Profile Your Application: Use profiling tools like Visual Studio Profiler to identify performance bottlenecks. This helps in pinpointing 
specific areas that require optimization.

Memory Optimizations: Implement object pooling, reduce object sizes, and prevent memory leaks to manage memory efficiently. This 
increases application scalability and reduces memory-related issues.

Avoid Dynamic Typing: Dynamic typing can lead to significant performance hits. Prefer strongly typed variables and properties to avoid 
runtime type checking overhead.

Use Efficient Algorithms and Data Structures: Identify performance-critical sections of your code and optimize them using efficient 
algorithms and data structures. Refactor code to eliminate unnecessary computations and loops.

Enable JIT Compiler Optimizations: Ensure that Just-In-Time (JIT) compiler optimizations are enabled in your application’s 
configuration. JIT optimizations can significantly improve runtime performance by optimizing code execution.

Synchronization Primitives: Use locks, mutexes, or semaphores to ensure thread-safe access to shared resources and avoid race 
conditions. Proper synchronization is crucial for multithreaded applications 5.

Client-Side Caching: Employ client-side caching to store frequently accessed or relatively static data, reducing the need for 
repeated network requests. This can significantly improve response times.

Reduce Network Round-Trip Time: Minimize the number of network round-trips by compressing data, employing HTTP compression, and 
lowering the size of payloads. This boosts the overall speed of your.NET application.

Asynchronous Programming: Avoid blocking calls and prefer asynchronous programming to run multiple processes simultaneously 
without blocking the main thread. This creates responsive and scalable applications.

Update.NET Framework and Libraries: Regularly update your.NET framework, libraries, and dependencies. Newer versions often come 
with performance improvements, bug fixes, and optimized algorithms.

---
1. Visual Studio Profiler
Description: Integrated into Visual Studio, the Visual Studio Profiler provides a comprehensive suite of tools for diagnosing 
             performance issues. It supports profiling C#, VB.NET, C++, F#, and more.
Features: Offers detailed insights into CPU usage, memory consumption, and application-level issues. It allows you to 
          visualize execution times and CPU usage, making it easier to identify bottlenecks.
Usage: Ideal for developers looking for a deep dive into application performance, especially when integrated with the Visual 
       Studio IDE for ease of use and analysis.
2..NET Async Tool
Description: Part of the Visual Studio Profiler, the.NET Async tool specifically targets asynchronous code performance.
Features: Displays start time, end time, and total time for each async operation, helping to identify inefficiencies in 
          asynchronous code paths.
Usage: Best suited for applications heavily reliant on asynchronous programming, where understanding the performance 
       characteristics of async operations is crucia
--------------------------------------------------------
Responsive web design (RWD) is an approach to web design that ensures your website looks great and functions well across various 
devices and screen sizes. Whether users access your site on desktops, tablets, or smartphones, responsive design adapts the layout, 
content, and user experience accordingly. By using techniques like CSS media queries, fluid layouts, and responsive images, you 
create a seamless browsing experience for everyone. 

--------------------------------------------------------
XSLT (Extensible Stylesheet Language Transformations) serves as a powerful tool for transforming and manipulating XML data. Its 
primary purposes include:

XML Transformation: XSLT allows you to convert XML documents into different formats (e.g., HTML, plain text, or other XML structures) by applying rules defined in an XSLT stylesheet.
Data Extraction and Filtering: You can extract specific data from an XML document using XSLT templates. For example, you can select nodes, filter content, and create new structures.
Styling and Presentation: XSLT enables you to define how XML data should be presented visually. You can apply styles, layout, and formatting rules to generate human-readable output.
Cross-Browser Compatibility: XSLT helps create consistent views of XML data across different browsers and devices by transforming it into HTML or other web-friendly formats.
Integration with Other Technologies: XSLT plays a role in integrating XML-based systems, such as transforming data for web services, APIs, or database interactions.
In summary, XSLT is essential for converting, styling, and manipulating XML data, making it more accessible and useful. 
--------------------------------------------------------
Basically TypeScript provides strong type checking on javascript.
--------------------------------------------------------
Using Microsoft mvc. When making a call to a controller action named Index, it should be an http GET request. It is default in .Net 8.
--------------------------------------------------------
In Microsoft MVC, when you make a call to a controller action named "Index", it typically corresponds to the default action 
that is invoked when you access a controller without specifying a particular action method. The HTTP request method used to 
call this action depends on how you configure your routes and how you intend to interact with the action.
--------------------------------------------------------
Why HTML Helpers in ASP.NET MVC?
HTML Helpers in ASP.NET MVC are utility methods that help generate HTML markup. They serve several purposes:
Abstraction of HTML: HTML Helpers abstract the low-level details of HTML markup generation. Instead of manually writing HTML 
tags in your views, you can use HTML Helpers to generate them programmatically.

Type Safety: HTML Helpers are strongly typed, meaning they are bound to specific data types. This ensures type safety during 
compile time, reducing the chances of runtime errors.

Code Reusability: By encapsulating common HTML patterns into reusable methods, HTML Helpers promote code reusability and 
maintainability. You can use them across multiple views and share them among different projects.

Intellisense Support: When you use HTML Helpers in your views, you benefit from Intellisense support in your IDE. This support 
provides helpful suggestions and auto-completion, making development faster and more efficient.

Security: Some HTML Helpers automatically handle the encoding of user input, helping prevent common security vulnerabilities 
such as Cross-Site Scripting (XSS) attacks.
--------------------------------------------------------
Similarities between Angular and React
https://www.copycat.dev/blog/angular-vs-react/
The following are some ways that Angular and React are similar:

Architecture: Component-based architecture is a feature of both Angular and React. These UI components are endlessly reusable and recyclable and are the building block of all React and Angular apps.
Open-source: Both tools are open-source. Due to the large development communities for React and Angular, they’re both regularly maintained and updated.
Client-side and Server-side rendering: Client-side and server-side rendering are both efficiently provided by Angular and React.
Performance: Performance-wise, Angular and React are comparable. The user’s perspective mostly determines the difference.
Development environment: Angular and React can both be used to create the front end of a mobile or online application.
Easy updating: Both Angular and React provide seamless updating. React is dependent on third-party libraries, whereas Angular leverages CLI.
Popularity: Both of these technologies are widely used by developers to create single-page applications(SPAs).
---
REACT
React’s virtual DOM implementation significantly boosts its speed such that it outperforms Angular. The burden on the browser is 
lessened since all virtual DOM trees are compact and created on the server. Furthermore, unlike in the case of Angular, the 
data-binding process is unidirectional; therefore, bindings are not given observers. No additional effort is generated in either respect.

ANGULAR
Angular has inferior performance, particularly when it comes to complex and dynamic websites.

This bidirectional data-binding process has a detrimental impact on the performance of Angular apps. A watcher is given to each binding 
to keep track of changes, and each loop iterates until all the watchers and their associated values have been evaluated. As a result, 
the more bindings you have, the more watchers are produced, making the procedure more arduous.
---
Testing
Attempting to reach 100% of testing objectives is challenging, especially when using a dynamically typed language like Javascript. 
Because of this, programs created in React must undergo a robust set of tests.

Angular includes a number of characteristics, including separation or isolation of the unit of code, and was created with testability 
in mind. It comes with inbuilt testing tools like Jasmine and Karma.

For instance, dependency injection, a built-in feature of Angular, makes it simple to pass in dependencies of components and test 
the components.

The availability of mocking capabilities in Reactjs makes tests more predictable.

As part of the development process, Reactjs continually runs test suites to perform the test cases. Additionally, it provides test 
execution tools like Mocha, Ava, React Testing Library and Jest, which enable testing to proceed concurrently with development.
---
Both React and Angular offer Typescript support. However, the difference between both tools is that Angular supports ONLY Typescript, 
which can often be a stumbling block for beginners trying to learn or use Angular.

React, however, supports Javascript and Typescript, making it a preferred option for developers. React also offers seamless codebase 
transitions from Javascript to Typescript and vice-versa.
---
Data binding is the process of synchronizing data between a Model and a View. Angular leverages changeable data and a two-way 
data-binding method. This implies that the model state will change when changes to the UI’s input occur, and vice versa.

React, on the other hand, employs a unidirectional (or one-way) data-binding procedure. As a result, changing a UI element does 
not alter a component’s state, which can facilitate debugging.
--------------------------------------------------------
Early binding in C# refers to compile-time binding where the type of an object and its associated methods are determined at compile 
time rather than at runtime. This means that method calls and property accesses are resolved when the code is compiled, leading to 
better performance and type safety.

Early binding contrasts with late binding, where methods are resolved at runtime, such as when using reflection or dynamic types 
(dynamic keyword). Since early binding checks types at compile time, it helps prevent errors and usually results in faster execution.
--------------------------------------------------------
In C#, a lambda expression is a concise way to create an anonymous function. It allows you to define a small block of code that 
can accept parameters and return a value. Here are the key points about lambda expressions:

Syntax:
An expression lambda has the form: (input-parameters) => expression.
A statement lambda has the form: (input-parameters) => { <sequence-of-statements> }.

Example:
An expression lambda that squares its input: x => x * x.
A statement lambda that performs more complex logic: (x, y) => { return x + y; }.

Delegate Types:
Lambda expressions can be converted to delegate types.
If a lambda doesn’t return a value, it can be an Action<T1, T2> delegate.
If it returns a value, it can be a Func<T, TResult> delegate.

Use Cases:
lambda are commonly used in LINQ queries, asynchronous code, and background tasks.
Example: numbers.Select(x => x * x) squares each number in an array.
Remember, lambda expressions provide a concise way to create anonymous functions in C#
--------------------------------------------------------
Static classes in C# can have private members. Static classes are designed to contain only static members, but within the class, 
you can declare private fields, properties, and methods that are accessible only within that class.

It is not possible to create an instance of a static class in C#. Static classes are designed to be non-instantiable.
--------------------------------------------------------
Web_Site_Security

The Antiforgery token in ASP.NET MVC is used to prevent Cross-Site Request Forgery (CSRF) attacks, which occur when a 
malicious site tricks a user into submitting unauthorized requests to a trusted website. Any authenticated user can 
be tricked into modifying state on your server by simply visiting a malicious website.
How an Antiforgery token Works
When a user loads a form in an MVC application, the server generates two tokens:
    One is stored in a cookie.
    The other is placed in a hidden form field.
    When the form is submitted, both tokens must be sent back to the server.

The server validates that the tokens match. If they don’t, the request is rejected.

Use @Html.AntiForgeryToken() inside your form. This generates a hidden input field containing the antiforgery token.

Apply [ValidateAntiForgeryToken] to your action method:
    HttpPost]
    [ValidateAntiForgeryToken]
    public IActionResult SubmitAction(string username)
    {
        // Process the request securely
        return View();
    }

If the token is missing or invalid → HTTP 400 Bad Request. Antiforgery tokens verify that form submissions come from real users 
interacting with your app — not malicious third-party sites trying to exploit authenticated sessions.

In .NET 8, you typically configure antiforgery globally to avoid having to sprinkle [ValidateAntiForgeryToken] everywhere.
You can wire it up globally at the middleware level.
Key points
This applies antiforgery globally on all unsafe HTTP methods.
No need to decorate individual controllers with [ValidateAntiForgeryToken].
Works for MVC, Razor Pages, or Minimal APIs.

Still requires that the client sends the antiforgery token (either as a form field or a header).
For APIs and AJAX requests
When you're working with APIs (especially SPAs), the common pattern is:
    Server sends the antiforgery token as a cookie (XSRF-TOKEN).
    Client reads it and sends it back in a header (X-CSRF-TOKEN).

If you're building a pure API that uses JWT tokens → CSRF protection usually isn’t necessary (because no cookies are involved).

---
Cross-site scripting (XSS) is a web security vulnerability that allows attackers to inject malicious scripts into web pages 
viewed by other users. These scripts can steal sensitive information, manipulate website content, or impersonate users.

There are three main types of XSS attacks:

Reflected XSS: The malicious script is included in a URL and executed when a user clicks the link.
Stored XSS: The script is permanently stored on a website (e.g., in a comment section) and runs whenever a user views the affected page.
DOM-based XSS: The attack occurs within the browser’s Document Object Model (DOM) without direct interaction with the server.

To prevent Cross-site scripting (XSS), developers should:
Sanitize and validate user input to remove harmful scripts.
Use Content Security Policy (CSP) to restrict script execution.
Escape output before rendering user-generated content.
---
ASP.NET Core MVC automatically encodes HTML output in Razor views, preventing direct execution of user input.
    @model MyModel
    <p>@Model.UserInput</p> // Automatically HTML-encoded

If you need to allow some HTML but filter out dangerous tags, consider using HtmlSanitizer.

Use HtmlEncoder to sanitize input before storing or processing: 
    string sanitizedInput = HtmlEncoder.Default.Encode(userInput);

Use AntiXSS Middleware
    Enable Request Filtering with AddAntiforgery() to block unexpected input in form.

Explicit Encoding with HtmlEncoder
If working with raw strings, encode output manually:
    @using System.Text.Encodings.Web
    @Html.Raw(HtmlEncoder.Default.Encode(Model.UserInput))

Enforce Content Security Policy (CSP)
CSP prevents inline scripts from executing. You can add a CSP header:
    app.Use(async (context, next) =>
    {
        context.Response.Headers.Add("Content-Security-Policy", "default-src 'self'; script-src 'self'");
        await next();
    });
    
Validate and Escape Input in JavaScript
Avoid inserting raw user input into JavaScript without sanitization:
    document.getElementById('message').innerText = userInput; // Safe
Instead of:
    document.getElementById('message').innerHTML = userInput; // Unsafe
---
Preventing Cross-Site Scripting (XSS) in Web APIs requires a combination of input validation, output encoding, and security 
headers to ensure malicious scripts don’t get executed in client applications. Here’s a structured approach for ASP.NET 
Core Web APIs:

Input Validation
Ensure that user input is properly validated before processing:
public class UserInput
{
    [Required]
    [MaxLength(50)]
    [RegularExpression(@"^[a-zA-Z0-9]*$", ErrorMessage = "Invalid characters in name")]
    public string Name { get; set; }
}
This prevents harmful characters from being injected into API requests.

Sanitize User Input
Use HtmlEncoder to sanitize input before storing or processing:
    using System.Text.Encodings.Web;
    tring sanitizedInput = HtmlEncoder.Default.Encode(userInput);
This ensures that special characters like < and > are encoded safely.

Output Encoding
Before returning data to clients, encode it to prevent execution:
    public IActionResult GetUser(string name)
    {
        var safeName = HtmlEncoder.Default.Encode(name);
        return Ok(new { Name = safeName });
    }
This prevents malicious scripts from being executed in the browser.


--------------------------------------------------------



--------------------------------------------------------

--------------------------------------------------------

--------------------------------------------------------

--------------------------------------------------------

--------------------------------------------------------

--------------------------------------------------------

--------------------------------------------------------